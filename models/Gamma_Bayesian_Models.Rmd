---
title: "Rstan Gamma Models"
author: "Charlotte Uden"
date: "2024-11-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE, include=FALSE}
library(rstan)
library(dplyr)
library(stats)
library(caret)
library(tidyr)
```

Load configuration files
- location of climate and lighting drivers
- location to store rds files - these files are generated by rstan and contain the saved models
- location to store tables containing parameter estimates, model predictions, and performance metrics
```{r}
read_properties <- function(file_path) {
  lines <- readLines(file_path)
  lines <- lines[grepl("=", lines)]  # only keep lines with key-value pairs
  key_vals <- strsplit(lines, "=")
  props <- setNames(
    trimws(sapply(key_vals, `[`, 2)),
    trimws(sapply(key_vals, `[`, 1))
  )
  return(props)
}

config <- read_properties("/path/to/config/file/my_config.properties")  # path to your config file

# Extract values from config
data_root <- config[["data_root"]]
rds_file_path <- config[["rds_root"]]
table_file_path <- config[["table_root"]]

# Use the values to build full paths
drivers_file_path <- file.path(data_root, "monthly_drivers.csv")
```

1. Read in the data

Make sure columns names are consistent with column names in this script: 
- lon (longitude)
- lat (latitude)
- year
- strikes (lightning strike rate, in flashes/km-2/month)
- cape (convective available potential energy, or CAPE in J kg-1)
- precip (precipitation in kg m-2 s-1)
- cxp (the product of CAPE and precipitation)
- tair (2 meter air temperature in degrees Celcius)
- wind (wind speed in m s-1)
- swr (shortwave radiation in W m-2)
- sp (surface pressure in Pa)
- rh (relative humidity expressed as a %)
Data should be summarized to monthly averages. 

```{r, echo=FALSE}
data <- read.csv(drivers_file_path)
#rename columns if necessary
#colnames(data) <- c("lon", "lat", "year", "strikes", "cape", "precip", "cxp", "tair", "wind", "swr", "sp", "rh")
```

2. Split into training and testing data
```{r, echo=FALSE}
## 80% of the sample size
sample_size <- floor(0.8 * nrow(data))

## set the seed to make partition reproducible
set.seed(123)
train_index <- sample(seq_len(nrow(data)), size = sample_size)

train <- data[train_index, ]
test <- data[-train_index, ]

```


3. Standardize predictor variables 
```{r, echo=FALSE}
#save min and max (normalization parameters?):
#-----
mu_cxp <- mean(train$cxp)
sigma_cxp <- sd(train$cxp)
mu_cape <- mean(train$cape)
sigma_cape <- sd(train$cape)
mu_precip <- mean(train$precip)
sigma_precip <- sd(train$precip)
mu_tair <- mean(train$tair)
sigma_tair <- sd(train$tair)
mu_wind <- mean(train$wind)
sigma_wind <- sd(train$wind)
mu_swr <- mean(train$swr)
sigma_swr <- sd(train$swr)
mu_sp <- mean(train$sp)
sigma_sp <- sd(train$sp)
mu_rh <- mean(train$rh)
sigma_rh <- sd(train$rh)
#-----

train <- train %>%
  mutate(cape = (cape-mu_cape)/sigma_cape) %>%
  mutate(precip = (precip-mu_precip)/sigma_precip) %>%
  mutate(cxp = (cxp-mu_cxp)/sigma_cxp) %>%
  mutate(tair = (tair-mu_tair)/sigma_tair) %>%
  mutate(wind = (wind-mu_wind)/sigma_wind) %>%
  mutate(swr = (swr-mu_swr)/sigma_swr) %>%
  mutate(sp = (sp-mu_sp)/sigma_sp) %>%
  mutate(rh = (rh-mu_rh)/sigma_rh) 

train <- train[,c("strikes", "cape", "precip", "cxp", "tair", "wind", "swr", "sp", "rh")]
head(train)

plot(train)

#Standardize using z-score standardization method
test <- test %>%
  mutate(cape = (cape-mu_cape)/sigma_cape) %>%
  mutate(precip = (precip-mu_precip)/sigma_precip) %>%
  mutate(cxp = (cxp-mu_cxp)/sigma_cxp) %>%
  mutate(tair = (tair-mu_tair)/sigma_tair) %>%
  mutate(wind = (wind-mu_wind)/sigma_wind) %>%
  mutate(swr = (swr-mu_swr)/sigma_swr) %>%
  mutate(sp = (sp-mu_sp)/sigma_sp) %>%
  mutate(rh = (rh-mu_rh)/sigma_rh) %>%
  mutate(lon = lon) %>%
  mutate(lat = lat)

test <- test[,c("lon", "lat", "strikes", "cape", "precip", "cxp", "tair", "wind", "swr", "sp", "rh")]

```


Model Comparison in Rstan:
Loo: Leave one out cross validation
WAIC: widely applicable information criterion



Calculate the S score from Perkins et al. 2007. The S score compares the distribution of predicted values with the distribution of observed values. Below is a function that computes the PDFâ€based skill score (Sscore) by binning two datasets (observed and predicted) into histograms with common breaks, converting counts to probabilities, and then summing the minimum probability in each bin. This approach allows the authors to assess whether the model can simulate rare events and the overall shape of the distribution, providing a more holistic evaluation of model performance.

The sscore is between 0 and 1 where scores close to one indicate that the distributions are similar. 


```{r}
calculate_sscore <- function(obs, pred, nbins = 15, plot = FALSE) {
  # Determine common break points based on the range of both datasets
  min_val <- min(c(obs, pred))
  max_val <- max(c(obs, pred))
  breaks <- seq(min_val, max_val, length.out = nbins + 1)
  
  # Compute histograms for observed and predicted data using the same breaks
  hist_obs <- hist(obs, breaks = breaks, plot = FALSE)
  hist_pred <- hist(pred, breaks = breaks, plot = FALSE)
  
  # Optionally, plot the histograms for visual inspection
  if (plot) {
    plot(hist_obs, col = rgb(1, 0, 0, 0.5), main = "Histograms", xlab = "Value")
    plot(hist_pred, col = rgb(0, 0, 1, 0.5), add = TRUE)
    legend("topright", legend = c("Observed", "Predicted"),
           fill = c(rgb(1, 0, 0, 0.5), rgb(0, 0, 1, 0.5)))
  }
  
  # Convert counts to probabilities so that they sum to 1 - for each bin, take the frequency 
  #(counts in that bin) and divide by total counts to get a proportion - or probability. 
  prob_obs <- hist_obs$counts / sum(hist_obs$counts)
  prob_pred <- hist_pred$counts / sum(hist_pred$counts)
  
  # Calculate the overlap: the sum over bins of the minimum probability in each bin.
  sscore <- sum(pmin(prob_obs, prob_pred))
  
  return(sscore)
}

```


# B1: CAPE

S ~ gamma(alpha, beta);
alpha = a_alpha + b_alpha * CAPE;
beta = a_beta + b_beta * CAPE;

```{r, echo=FALSE, results='hide', include=FALSE}

#library(rstan)

dat <- list(
  N = nrow(train),
  S = train$strikes,
  CAPE = train$cape
)

#This code chunk checks to see if the compiled model is already saved in the rds_file_path location that was defined at the begining of the script. If it wasn't saved, it makes the rds file and saves it. if it was saved, it opens the compiled model. 
if (!file.exists(file.path(rds_file_path, "compiled_gamma_B1.rds"))) {
  B1 <- stan(file = "gamma_cape.stan", data = dat, 
           iter = 2000, 
           chains = 4, 
           cores = min(parallel::detectCores(), 4))
    saveRDS(B1, file = file.path(rds_file_path, "compiled_gamma_B1.rds"))
    } else {
      B1 <- readRDS(file.path(rds_file_path, "compiled_gamma_B1.rds"))
    }

```


```{r}

print(B1, pars = c("a_alpha", "b_alpha", "a_beta", "b_beta"))

traceplot(B1)

parameter_stats <- summary(B1)$summary[, c("mean", "sd")][1:4, 1:2]
print(parameter_stats)

summary_table <- data.frame(
  parameter = rownames(parameter_stats),
  mean = parameter_stats[, "mean"],
  sd = parameter_stats[, "sd"]
)

ggplot(summary_table, aes(x = parameter, y = mean)) +
  geom_point(size = 3) +  # Point for the mean
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2) +  # Error bars for SD
  labs(y = "Parameter Estimate", x = "Parameter") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Parameter Means and SDs from Stan Model")

#save parameter values
a_alpha <- summary_table["a_alpha", "mean"]
b_alpha <- summary_table["b_alpha", "mean"]
a_beta <- summary_table["a_beta", "mean"]
b_beta  <- summary_table["b_beta ", "mean"]

```

Make predictions
```{r}
#Extract posterior samples
posterior_samples <- as.data.frame(B1)

#Extract individual parameters
a_alpha_samples <- posterior_samples$a_alpha
b_alpha_samples <- posterior_samples$b_alpha
a_beta_samples <- posterior_samples$a_beta
b_beta_samples <- posterior_samples$b_beta

#Number of posterior samples
num_samples <- length(a_alpha_samples)

#Number of test observations
num_test <- length(test$cape)

#Create vectors to store sampled alpha, beta, and predictions
sampled_alpha <- numeric(num_test)
sampled_beta <- numeric(num_test)
sampled_predictions <- numeric(num_test)

#Randomly select a posterior sample for each test observation
posterior_index <- sample(1:num_samples, num_test, replace = TRUE)

for (j in 1:num_test) {
  #Pick a random posterior sample index
  i <- posterior_index[j]  

  #Compute alpha and beta for the test observation
  sampled_alpha[j] <- a_alpha_samples[i] + b_alpha_samples[i] * test$cape[j]
  sampled_beta[j] <- a_beta_samples[i] + b_beta_samples[i] * test$cape[j]
  
  #Generate a single prediction from the Gamma distribution
  sampled_predictions[j] <- rgamma(1, shape = sampled_alpha[j], rate = sampled_beta[j])
}

#Create a dataframe with observed and predicted values
predictions_df <- data.frame(
  actual = test$strikes,      #Observed lightning strikes
  cape = test$cape,            #Climate predictor 
  alpha = sampled_alpha,      #Sampled alpha for each observation
  beta = sampled_beta,        #Sampled beta for each observation
  sampled_pred = sampled_predictions  # Sampled prediction
)

#View predictions
print(head(predictions_df))

hist(predictions_df$sampled_pred, breaks=30, main = "predictions")

hist(test$strikes, breaks=30, main = "observations")

plot(test$cape, predictions_df$alpha, main="Alpha")
plot(test$cape, predictions_df$beta, main="Beta")
plot(test$cape, predictions_df$sampled_pred, main="Lightning Predictions")
plot(test$cape, test$strikes, main="Lightning Observations")
plot(predictions_df$sampled_pred, test$strikes, main="Observed vs. Predicted")
abline(a = 0, b = 1, col = "red", lty = 2, lwd = 2)

#store predictions for figures 
y_pred_B1 <- predictions_df$sampled_pred
```

Performance metrics and Parameter Estimate table
```{r}
rmse_B1 <- RMSE(y_pred_B1, test$strikes)
sscore_B1 <- calculate_sscore(obs=test$strikes, pred=y_pred_B1, nbins = 15, plot = FALSE)
cor_B1 <- cor(test$strikes, y_pred_B1)

param_table <- data.frame(cbind(scale = c("seasonal"),
                          distribution = c("gamma"),
                          model_name = c("B1"),
                          climate_var = c("CAPE"),
                          alpha = c("a_alpha + b_alpha * CAPE"),
                          a_alpha = a_alpha,
                          b_alpha = b_alpha,
                          c_alpha = NA,
                          d_alpha = NA,
                          e_alpha = NA,
                          f_alpha = NA,
                          g_alpha = NA,
                          beta = c("a_beta + b_beta * CAPE"),
                          a_beta = a_beta,
                          b_beta = b_beta,
                          c_beta = NA,
                          d_beta = NA,
                          e_beta = NA,
                          f_beta = NA,
                          g_beta = NA))

```

# B2: CAPE x Precipitation

S ~ gamma(alpha, beta);
alpha = a_alpha + b_alpha * CXP;
beta = a_beta + b_beta * CXP;

```{r, echo=FALSE, results='hide', include=FALSE}

#library(rstan)

dat <- list(
  N = nrow(train),
  S = train$strikes,
  CXP = train$cxp
)


# Compile and fit the Stan model
if (!file.exists(file.path(rds_file_path, "compiled_gamma_B2.rds"))) {
  B2 <- stan(file = "gamma_cxp.stan", data = dat, 
           iter = 2000, 
           chains = 4, 
           cores = min(parallel::detectCores(), 4))
    saveRDS(B2, file = file.path(rds_file_path, "compiled_gamma_B2.rds"))
    } else {
      B2 <- readRDS(file.path(rds_file_path, "compiled_gamma_B2.rds"))
    }
```


```{r}

print(B2, pars = c("a_alpha", "b_alpha", "a_beta", "b_beta"))

traceplot(B2)

parameter_stats <- summary(B2)$summary[, c("mean", "sd")][1:4, 1:2]
print(parameter_stats)

summary_table <- data.frame(
  parameter = rownames(parameter_stats),
  mean = parameter_stats[, "mean"],
  sd = parameter_stats[, "sd"]
)

ggplot(summary_table, aes(x = parameter, y = mean)) +
  geom_point(size = 3) +  # Point for the mean
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2) +  # Error bars for SD
  labs(y = "Parameter Estimate", x = "Parameter") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Parameter Means and SDs from Stan Model")

a_alpha <- summary_table["a_alpha", "mean"]
b_alpha <- summary_table["b_alpha", "mean"]
a_beta <- summary_table["a_beta", "mean"]
b_beta  <- summary_table["b_beta ", "mean"]
```

Make predictions
```{r}
#Extract posterior samples
posterior_samples <- as.data.frame(B2)

#Extract individual parameters
a_alpha_samples <- posterior_samples$a_alpha
b_alpha_samples <- posterior_samples$b_alpha
a_beta_samples <- posterior_samples$a_beta
b_beta_samples <- posterior_samples$b_beta

#Number of posterior samples
num_samples <- length(a_alpha_samples)

#Number of test observations
num_test <- length(test$cxp)

#Create vectors to store sampled alpha, beta, and predictions
sampled_alpha <- numeric(num_test)
sampled_beta <- numeric(num_test)
sampled_predictions <- numeric(num_test)

#Randomly select a posterior sample for each test observation
posterior_index <- sample(1:num_samples, num_test, replace = TRUE)

for (j in 1:num_test) {
  #Pick a random posterior sample index
  i <- posterior_index[j]  

  #Compute alpha and beta for the test observation
  sampled_alpha[j] <- a_alpha_samples[i] + b_alpha_samples[i] * test$cxp[j]
  sampled_beta[j] <- a_beta_samples[i] + b_beta_samples[i] * test$cxp[j]
  
  #Generate a single prediction from the Gamma distribution
  sampled_predictions[j] <- rgamma(1, shape = sampled_alpha[j], rate = sampled_beta[j])
}

#Create a dataframe with observed and predicted values
predictions_df <- data.frame(
  actual = test$strikes,      #Observed lightning strikes
  cxp = test$cxp,            #Climate predictor 
  alpha = sampled_alpha,      #Sampled alpha for each observation
  beta = sampled_beta,        #Sampled beta for each observation
  sampled_pred = sampled_predictions  # Sampled prediction
)

#View predictions
print(head(predictions_df))

hist(predictions_df$sampled_pred, breaks=30, main = "predictions")

hist(test$strikes, breaks=30, main = "observations")

plot(test$cxp, predictions_df$alpha, main="Alpha")
plot(test$cxp, predictions_df$beta, main="Beta")
plot(test$cxp, predictions_df$sampled_pred, main="Lightning Predictions")
plot(test$cxp, test$strikes, main="Lightning Observations")
plot(predictions_df$sampled_pred, test$strikes, main="Observed vs. Predicted")
abline(a = 0, b = 1, col = "red", lty = 2, lwd = 2)

#store predictions for figures 
y_pred_B2 <- predictions_df$sampled_pred
```

```{r}
rmse_B2 <- RMSE(y_pred_B2, test$strikes)
sscore_B2 <- calculate_sscore(obs=test$strikes, pred=y_pred_B2, nbins = 15, plot = FALSE)
cor_B2 <- cor(test$strikes, y_pred_B2)
  
param_table <- rbind(param_table, data.frame(scale = c("seasonal"),
                          distribution = c("gamma"),
                          model_name = c("B2"),
                          climate_var = c("CXP"),
                          alpha = c("a_alpha + b_alpha * CXP"),
                          a_alpha = a_alpha,
                          b_alpha = b_alpha,
                          c_alpha = NA,
                          d_alpha = NA,
                          e_alpha = NA,
                          f_alpha = NA,
                          g_alpha = NA,
                          beta = c("a_beta + b_beta * CXP"),
                          a_beta = a_beta,
                          b_beta = b_beta,
                          c_beta = NA,
                          d_beta = NA,
                          e_beta = NA,
                          f_beta = NA,
                          g_beta = NA))

```

# B3: Relative Humidity

S ~ gamma(alpha, beta);
alpha = a_alpha + b_alpha * RH;
beta = a_beta + b_beta * RH;

```{r, echo=FALSE, results='hide', include=FALSE}

#library(rstan)

dat <- list(
  N = nrow(train),
  S = train$strikes,
  RH = train$rh
)


# Compile and fit the Stan model
if (!file.exists(file.path(rds_file_path, "compiled_gamma_B3.rds"))) {
  B3 <- stan(file = "gamma_rh.stan", data = dat, 
           iter = 2000, 
           chains = 4, 
           cores = min(parallel::detectCores(), 4))
    saveRDS(B3, file = file.path(rds_file_path, "compiled_gamma_B3.rds"))
    } else {
      B3 <- readRDS(file.path(rds_file_path, "compiled_gamma_B3.rds"))
    }
```


```{r}

print(B3, pars = c("a_alpha", "b_alpha", "a_beta", "b_beta"))

traceplot(B3)

parameter_stats <- summary(B3)$summary[, c("mean", "sd")][1:4, 1:2]
print(parameter_stats)

summary_table <- data.frame(
  parameter = rownames(parameter_stats),
  mean = parameter_stats[, "mean"],
  sd = parameter_stats[, "sd"]
)

ggplot(summary_table, aes(x = parameter, y = mean)) +
  geom_point(size = 3) +  # Point for the mean
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2) +  # Error bars for SD
  labs(y = "Parameter Estimate", x = "Parameter") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Parameter Means and SDs from Stan Model")

#save store mean posterior sample for table 
a_alpha <- summary_table["a_alpha", "mean"]
b_alpha <- summary_table["b_alpha", "mean"]
a_beta <- summary_table["a_beta", "mean"]
b_beta  <- summary_table["b_beta ", "mean"]
```

Make predictions
```{r}
#Extract posterior samples
posterior_samples <- as.data.frame(B3)

#Extract individual parameters
a_alpha_samples <- posterior_samples$a_alpha
b_alpha_samples <- posterior_samples$b_alpha
a_beta_samples <- posterior_samples$a_beta
b_beta_samples <- posterior_samples$b_beta

#Number of posterior samples
num_samples <- length(a_alpha_samples)

#Number of test observations
num_test <- length(test$rh)

#Create vectors to store sampled alpha, beta, and predictions
sampled_alpha <- numeric(num_test)
sampled_beta <- numeric(num_test)
sampled_predictions <- numeric(num_test)

#Randomly select a posterior sample for each test observation
posterior_index <- sample(1:num_samples, num_test, replace = TRUE)

for (j in 1:num_test) {
  #Pick a random posterior sample index
  i <- posterior_index[j]  

  #Compute alpha and beta for the test observation
  sampled_alpha[j] <- a_alpha_samples[i] + b_alpha_samples[i] * test$rh[j]
  sampled_beta[j] <- a_beta_samples[i] + b_beta_samples[i] * test$rh[j]
  
  #Generate a single prediction from the Gamma distribution
  sampled_predictions[j] <- rgamma(1, shape = sampled_alpha[j], rate = sampled_beta[j])
}

#Create a dataframe with observed and predicted values
predictions_df <- data.frame(
  actual = test$strikes,      #Observed lightning strikes
  rh = test$rh,            #Climate predictor 
  alpha = sampled_alpha,      #Sampled alpha for each observation
  beta = sampled_beta,        #Sampled beta for each observation
  sampled_pred = sampled_predictions  # Sampled prediction
)

#View predictions
print(head(predictions_df))

hist(predictions_df$sampled_pred, breaks=30, main = "predictions")

hist(test$strikes, breaks=30, main = "observations")

plot(test$rh, predictions_df$alpha, main="Alpha")
plot(test$rh, predictions_df$beta, main="Beta")
plot(test$rh, predictions_df$sampled_pred, main="Lightning Predictions")
plot(test$rh, test$strikes, main="Lightning Observations")
plot(predictions_df$sampled_pred, test$strikes, main="Observed vs. Predicted")
abline(a = 0, b = 1, col = "red", lty = 2, lwd = 2)

#store predictions for figures 
y_pred_B3 <- predictions_df$sampled_pred
```

Performance metrics and store mean posterior sample for table
```{r}
rmse_B3 <- RMSE(y_pred_B3, test$strikes)
sscore_B3 <- calculate_sscore(obs=test$strikes, pred=y_pred_B3, nbins = 15, plot = FALSE)
cor_B3 <- cor(test$strikes, y_pred_B3)

param_table <- rbind(param_table, data.frame(scale = c("seasonal"),
                          distribution = c("gamma"),
                          model_name = c("B3"),
                          climate_var = c("RH"),
                          alpha = c("a_alpha + b_alpha * RH"),
                          a_alpha = a_alpha,
                          b_alpha = b_alpha,
                          c_alpha = NA,
                          d_alpha = NA,
                          e_alpha = NA,
                          f_alpha = NA,
                          g_alpha = NA,
                          beta = c("a_beta + b_beta * RH"),
                          a_beta = a_beta,
                          b_beta = b_beta,
                          c_beta = NA,
                          d_beta = NA,
                          e_beta = NA,
                          f_beta = NA,
                          g_beta = NA))

```

# B4: Short Wave Radiation

S ~ gamma(alpha, beta);
alpha = a_alpha + b_alpha * SWR;
beta = a_beta + b_beta * SWR;

```{r, echo=FALSE, results='hide', include=FALSE}

#library(rstan)

dat <- list(
  N = nrow(train),
  S = train$strikes,
  SWR = train$swr
)


# Compile and fit the Stan model
if (!file.exists(file.path(rds_file_path, "compiled_gamma_B4.rds"))) {
  B4 <- stan(file = "gamma_swr.stan", data = dat, 
           iter = 2000, 
           chains = 4, 
           cores = min(parallel::detectCores(), 4))
    saveRDS(B4, file = file.path(rds_file_path, "compiled_gamma_B4.rds"))
    } else {
      B4 <- readRDS(file.path(rds_file_path, "compiled_gamma_B4.rds"))
    }

```


```{r}

print(B4, pars = c("a_alpha", "b_alpha", "a_beta", "b_beta"))

traceplot(B4)

parameter_stats <- summary(B4)$summary[, c("mean", "sd")][1:4, 1:2]
print(parameter_stats)

summary_table <- data.frame(
  parameter = rownames(parameter_stats),
  mean = parameter_stats[, "mean"],
  sd = parameter_stats[, "sd"]
)

ggplot(summary_table, aes(x = parameter, y = mean)) +
  geom_point(size = 3) +  # Point for the mean
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2) +  # Error bars for SD
  labs(y = "Parameter Estimate", x = "Parameter") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Parameter Means and SDs from Stan Model")

#store mean posterior sample for table 
a_alpha <- summary_table["a_alpha", "mean"]
b_alpha <- summary_table["b_alpha", "mean"]
a_beta <- summary_table["a_beta", "mean"]
b_beta  <- summary_table["b_beta ", "mean"]
```

Make predictions
```{r}
#Extract posterior samples
posterior_samples <- as.data.frame(B4)

#Extract individual parameters
a_alpha_samples <- posterior_samples$a_alpha
b_alpha_samples <- posterior_samples$b_alpha
a_beta_samples <- posterior_samples$a_beta
b_beta_samples <- posterior_samples$b_beta

#Number of posterior samples
num_samples <- length(a_alpha_samples)

#Number of test observations
num_test <- length(test$swr)

#Create vectors to store sampled alpha, beta, and predictions
sampled_alpha <- numeric(num_test)
sampled_beta <- numeric(num_test)
sampled_predictions <- numeric(num_test)

#Randomly select a posterior sample for each test observation
posterior_index <- sample(1:num_samples, num_test, replace = TRUE)

for (j in 1:num_test) {
  #Pick a random posterior sample index
  i <- posterior_index[j]  

  #Compute alpha and beta for the test observation
  sampled_alpha[j] <- a_alpha_samples[i] + b_alpha_samples[i] * test$swr[j]
  sampled_beta[j] <- a_beta_samples[i] + b_beta_samples[i] * test$swr[j]
  
  #Generate a single prediction from the Gamma distribution
  sampled_predictions[j] <- rgamma(1, shape = sampled_alpha[j], rate = sampled_beta[j])
}

#Create a dataframe with observed and predicted values
predictions_df <- data.frame(
  actual = test$strikes,      #Observed lightning strikes
  swr = test$swr,            #Climate predictor 
  alpha = sampled_alpha,      #Sampled alpha for each observation
  beta = sampled_beta,        #Sampled beta for each observation
  sampled_pred = sampled_predictions  # Sampled prediction
)

#View predictions
print(head(predictions_df))

hist(predictions_df$sampled_pred, breaks=30, main = "predictions")

hist(test$strikes, breaks=30, main = "observations")

plot(test$swr, predictions_df$alpha, main="Alpha")
plot(test$swr, predictions_df$beta, main="Beta")
plot(test$swr, predictions_df$sampled_pred, main="Lightning Predictions")
plot(test$swr, test$strikes, main="Lightning Observations")
plot(predictions_df$sampled_pred, test$strikes, main="Observed vs. Predicted")
abline(a = 0, b = 1, col = "red", lty = 2, lwd = 2)

#store predictions for figures 
y_pred_B4 <- predictions_df$sampled_pred
```

Performance metrics and store mean posterior sample for table
```{r}
rmse_B4 <- RMSE(y_pred_B4, test$strikes)
sscore_B4 <- calculate_sscore(obs=test$strikes, pred=y_pred_B4, nbins = 15, plot = FALSE)
cor_B4 <- cor(test$strikes, y_pred_B4)

param_table <- rbind(param_table, data.frame(scale = c("seasonal"),
                          distribution = c("gamma"),
                          model_name = c("B4"),
                          climate_var = c("SWR"),
                          alpha = c("a_alpha + b_alpha * SWR"),
                          a_alpha = a_alpha,
                          b_alpha = b_alpha,
                          c_alpha = NA,
                          d_alpha = NA,
                          e_alpha = NA,
                          f_alpha = NA,
                          g_alpha = NA,
                          beta = c("a_beta + b_beta * SWR"),
                          a_beta = a_beta,
                          b_beta = b_beta,
                          c_beta = NA,
                          d_beta = NA,
                          e_beta = NA,
                          f_beta = NA,
                          g_beta = NA))
```

# B5: Temperature

S ~ gamma(alpha, beta);
alpha = a_alpha + b_alpha * T;
beta = a_beta + b_beta * T;

```{r, echo=FALSE, results='hide', include=FALSE}

#library(rstan)

dat <- list(
  N = nrow(train),
  S = train$strikes,
  T = train$tair
)


# Compile and fit the Stan model
if (!file.exists(file.path(rds_file_path, "compiled_gamma_B5.rds"))) {
  B5 <- stan(file = "gamma_tair.stan", data = dat, 
           iter = 2000, 
           chains = 4, 
           cores = min(parallel::detectCores(), 4))
    saveRDS(B5, file = file.path(rds_file_path, "compiled_gamma_B5.rds"))
    } else {
      B5 <- readRDS(file.path(rds_file_path, "compiled_gamma_B5.rds"))
    }
```


```{r}

print(B5, pars = c("a_alpha", "b_alpha", "a_beta", "b_beta"))

traceplot(B5)

parameter_stats <- summary(B5)$summary[, c("mean", "sd")][1:4, 1:2]
print(parameter_stats)

summary_table <- data.frame(
  parameter = rownames(parameter_stats),
  mean = parameter_stats[, "mean"],
  sd = parameter_stats[, "sd"]
)

ggplot(summary_table, aes(x = parameter, y = mean)) +
  geom_point(size = 3) +  # Point for the mean
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2) +  # Error bars for SD
  labs(y = "Parameter Estimate", x = "Parameter") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Parameter Means and SDs from Stan Model")

#store mean posterior sample for table 
a_alpha <- summary_table["a_alpha", "mean"]
b_alpha <- summary_table["b_alpha", "mean"]
a_beta <- summary_table["a_beta", "mean"]
b_beta  <- summary_table["b_beta ", "mean"]
```

Make predictions
```{r}
#Extract posterior samples
posterior_samples <- as.data.frame(B5)

#Extract individual parameters
a_alpha_samples <- posterior_samples$a_alpha
b_alpha_samples <- posterior_samples$b_alpha
a_beta_samples <- posterior_samples$a_beta
b_beta_samples <- posterior_samples$b_beta

#Number of posterior samples
num_samples <- length(a_alpha_samples)

#Number of test observations
num_test <- length(test$tair)

#Create vectors to store sampled alpha, beta, and predictions
sampled_alpha <- numeric(num_test)
sampled_beta <- numeric(num_test)
sampled_predictions <- numeric(num_test)

#Randomly select a posterior sample for each test observation
posterior_index <- sample(1:num_samples, num_test, replace = TRUE)

for (j in 1:num_test) {
  #Pick a random posterior sample index
  i <- posterior_index[j]  

  #Compute alpha and beta for the test observation
  sampled_alpha[j] <- a_alpha_samples[i] + b_alpha_samples[i] * test$tair[j]
  sampled_beta[j] <- a_beta_samples[i] + b_beta_samples[i] * test$tair[j]
  
  #Generate a single prediction from the Gamma distribution
  sampled_predictions[j] <- rgamma(1, shape = sampled_alpha[j], rate = sampled_beta[j])
}

#Create a dataframe with observed and predicted values
predictions_df <- data.frame(
  actual = test$strikes,      #Observed lightning strikes
  tair = test$tair,            #Climate predictor 
  alpha = sampled_alpha,      #Sampled alpha for each observation
  beta = sampled_beta,        #Sampled beta for each observation
  sampled_pred = sampled_predictions  # Sampled prediction
)

#View predictions
print(head(predictions_df))

hist(predictions_df$sampled_pred, breaks=30, main = "predictions")

hist(test$strikes, breaks=30, main = "observations")

plot(test$tair, predictions_df$alpha, main="Alpha")
plot(test$tair, predictions_df$beta, main="Beta")
plot(test$tair, predictions_df$sampled_pred, main="Lightning Predictions")
plot(test$tair, test$strikes, main="Lightning Observations")
plot(predictions_df$sampled_pred, test$strikes, main="Observed vs. Predicted")
abline(a = 0, b = 1, col = "red", lty = 2, lwd = 2)

#store predictions for figures 
y_pred_B5 <- predictions_df$sampled_pred
```

```{r}
rmse_B5 <- RMSE(y_pred_B5, test$strikes)
sscore_B5 <- calculate_sscore(obs=test$strikes, pred=y_pred_B5, nbins = 15, plot = FALSE)
cor_B5 <- cor(test$strikes, y_pred_B5)

param_table <- rbind(param_table, data.frame(scale = c("seasonal"),
                          distribution = c("gamma"),
                          model_name = c("B5"),
                          climate_var = c("T"),
                          alpha = c("a_alpha + b_alpha * T"),
                          a_alpha = a_alpha,
                          b_alpha = b_alpha,
                          c_alpha = NA,
                          d_alpha = NA,
                          e_alpha = NA,
                          f_alpha = NA,
                          g_alpha = NA,
                          beta = c("a_beta + b_beta * T"),
                          a_beta = a_beta,
                          b_beta = b_beta,
                          c_beta = NA,
                          d_beta = NA,
                          e_beta = NA,
                          f_beta = NA,
                          g_beta = NA))

```

# B6: Surface Pressure

S ~ gamma(alpha, beta);
alpha = a_alpha + b_alpha * SP;
beta = a_beta + b_beta * SP;

```{r, echo=FALSE, results='hide', include=FALSE}

#library(rstan)

dat <- list(
  N = nrow(train),
  S = train$strikes,
  SP = train$sp
)


# Compile and fit the Stan model
if (!file.exists(file.path(rds_file_path, "compiled_gamma_B6.rds"))) {
  B6 <- stan(file = "gamma_sp.stan", data = dat, 
           iter = 2000, 
           chains = 4, 
           cores = min(parallel::detectCores(), 4))
    saveRDS(B6, file = file.path(rds_file_path, "compiled_gamma_B6.rds"))
    } else {
      B6 <- readRDS(file.path(rds_file_path, "compiled_gamma_B6.rds"))
    }
```


```{r}

print(B6, pars = c("a_alpha", "b_alpha", "a_beta", "b_beta"))

traceplot(B6)

parameter_stats <- summary(B6)$summary[, c("mean", "sd")][1:4, 1:2]
print(parameter_stats)

summary_table <- data.frame(
  parameter = rownames(parameter_stats),
  mean = parameter_stats[, "mean"],
  sd = parameter_stats[, "sd"]
)

ggplot(summary_table, aes(x = parameter, y = mean)) +
  geom_point(color = "blue", size = 3) +  # Point for the mean
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2) +  # Error bars for SD
  labs(y = "Parameter Estimate", x = "Parameter") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Parameter Means and SDs from Stan Model")

#store mean posterior sample for table 
a_alpha <- summary_table["a_alpha", "mean"]
b_alpha <- summary_table["b_alpha", "mean"]
a_beta <- summary_table["a_beta", "mean"]
b_beta  <- summary_table["b_beta ", "mean"]
```

Make predictions
```{r}
#Extract posterior samples
posterior_samples <- as.data.frame(B6)

#Extract individual parameters
a_alpha_samples <- posterior_samples$a_alpha
b_alpha_samples <- posterior_samples$b_alpha
a_beta_samples <- posterior_samples$a_beta
b_beta_samples <- posterior_samples$b_beta

#Number of posterior samples
num_samples <- length(a_alpha_samples)

#Number of test observations
num_test <- length(test$sp)

#Create vectors to store sampled alpha, beta, and predictions
sampled_alpha <- numeric(num_test)
sampled_beta <- numeric(num_test)
sampled_predictions <- numeric(num_test)

#Randomly select a posterior sample for each test observation
posterior_index <- sample(1:num_samples, num_test, replace = TRUE)

for (j in 1:num_test) {
  #Pick a random posterior sample index
  i <- posterior_index[j]  

  #Compute alpha and beta for the test observation
  sampled_alpha[j] <- a_alpha_samples[i] + b_alpha_samples[i] * test$sp[j]
  sampled_beta[j] <- a_beta_samples[i] + b_beta_samples[i] * test$sp[j]
  
  #Generate a single prediction from the Gamma distribution
  sampled_predictions[j] <- rgamma(1, shape = sampled_alpha[j], rate = sampled_beta[j])
}

#Create a dataframe with observed and predicted values
predictions_df <- data.frame(
  actual = test$strikes,      #Observed lightning strikes
  sp = test$sp,            #Climate predictor 
  alpha = sampled_alpha,      #Sampled alpha for each observation
  beta = sampled_beta,        #Sampled beta for each observation
  sampled_pred = sampled_predictions  # Sampled prediction
)

#View predictions
print(head(predictions_df))

hist(predictions_df$sampled_pred, breaks=30, main = "predictions")

hist(test$strikes, breaks=30, main = "observations")

plot(test$sp, predictions_df$alpha, main="Alpha")
plot(test$sp, predictions_df$beta, main="Beta")
plot(test$sp, predictions_df$sampled_pred, main="Lightning Predictions")
plot(test$sp, test$strikes, main="Lightning Observations")
plot(predictions_df$sampled_pred, test$strikes, main="Observed vs. Predicted")
abline(a = 0, b = 1, col = "red", lty = 2, lwd = 2)

#store predictions for figures 
y_pred_B6 <- predictions_df$sampled_pred
```

```{r}
rmse_B6 <- RMSE(y_pred_B6, test$strikes)
sscore_B6 <- calculate_sscore(obs=test$strikes, pred=y_pred_B6, nbins = 15, plot = FALSE)
cor_B6 <- cor(test$strikes, y_pred_B6)

param_table <- rbind(param_table, data.frame(scale = c("seasonal"),
                          distribution = c("gamma"),
                          model_name = c("B6"),
                          climate_var = c("SP"),
                          alpha = c("a_alpha + b_alpha * SP"),
                          a_alpha = a_alpha,
                          b_alpha = b_alpha,
                          c_alpha = NA,
                          d_alpha = NA,
                          e_alpha = NA,
                          f_alpha = NA,
                          g_alpha = NA,
                          beta = c("a_beta + b_beta * SP"),
                          a_beta = a_beta,
                          b_beta = b_beta,
                          c_beta = NA,
                          d_beta = NA,
                          e_beta = NA,
                          f_beta = NA,
                          g_beta = NA))

```


# B7: Precipitation

S ~ gamma(alpha, beta);
alpha = a_alpha + b_alpha * P;
beta = a_beta + b_beta * P;

```{r, echo=FALSE, results='hide', include=FALSE}

#library(rstan)

dat <- list(
  N = nrow(train),
  S = train$strikes,
  P = train$precip
)


# Compile and fit the Stan model
if (!file.exists(file.path(rds_file_path, "compiled_gamma_B7.rds"))) {
  B7 <- stan(file = "gamma_precip.stan", data = dat, 
           iter = 2000, 
           chains = 4, 
           cores = min(parallel::detectCores(), 4))
    saveRDS(B7, file = file.path(rds_file_path, "compiled_gamma_B7.rds"))
    } else {
      B7 <- readRDS(file.path(rds_file_path, "compiled_gamma_B7.rds"))
    }
```


```{r}

print(B7, pars = c("a_alpha", "b_alpha", "a_beta", "b_beta"))

traceplot(B7)

parameter_stats <- summary(B7)$summary[, c("mean", "sd")][1:4, 1:2]
print(parameter_stats)

summary_table <- data.frame(
  parameter = rownames(parameter_stats),
  mean = parameter_stats[, "mean"],
  sd = parameter_stats[, "sd"]
)

ggplot(summary_table, aes(x = parameter, y = mean)) +
  geom_point(color = "blue", size = 3) +  # Point for the mean
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2) +  # Error bars for SD
  labs(y = "Parameter Estimate", x = "Parameter") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Parameter Means and SDs from Stan Model")

#store mean posterior sample for table 
a_alpha <- summary_table["a_alpha", "mean"]
b_alpha <- summary_table["b_alpha", "mean"]
a_beta <- summary_table["a_beta", "mean"]
b_beta  <- summary_table["b_beta ", "mean"]
```

Make predictions
```{r}
#Extract posterior samples
posterior_samples <- as.data.frame(B7)

#Extract individual parameters
a_alpha_samples <- posterior_samples$a_alpha
b_alpha_samples <- posterior_samples$b_alpha
a_beta_samples <- posterior_samples$a_beta
b_beta_samples <- posterior_samples$b_beta

#Number of posterior samples
num_samples <- length(a_alpha_samples)

#Number of test observations
num_test <- length(test$precip)

#Create vectors to store sampled alpha, beta, and predictions
sampled_alpha <- numeric(num_test)
sampled_beta <- numeric(num_test)
sampled_predictions <- numeric(num_test)

#Randomly select a posterior sample for each test observation
posterior_index <- sample(1:num_samples, num_test, replace = TRUE)

for (j in 1:num_test) {
  #Pick a random posterior sample index
  i <- posterior_index[j]  

  #Compute alpha and beta for the test observation
  sampled_alpha[j] <- a_alpha_samples[i] + b_alpha_samples[i] * test$precip[j]
  sampled_beta[j] <- a_beta_samples[i] + b_beta_samples[i] * test$precip[j]
  
  #Generate a single prediction from the Gamma distribution
  sampled_predictions[j] <- rgamma(1, shape = sampled_alpha[j], rate = sampled_beta[j])
}

#Create a dataframe with observed and predicted values
predictions_df <- data.frame(
  actual = test$strikes,      #Observed lightning strikes
  precip = test$precip,            #Climate predictor 
  alpha = sampled_alpha,      #Sampled alpha for each observation
  beta = sampled_beta,        #Sampled beta for each observation
  sampled_pred = sampled_predictions  # Sampled prediction
)

#View predictions
print(head(predictions_df))

hist(predictions_df$sampled_pred, breaks=30, main = "predictions")

hist(test$strikes, breaks=30, main = "observations")

plot(test$precip, predictions_df$alpha, main="Alpha")
plot(test$precip, predictions_df$beta, main="Beta")
plot(test$precip, predictions_df$sampled_pred, main="Lightning Predictions")
plot(test$precip, test$strikes, main="Lightning Observations")
plot(predictions_df$sampled_pred, test$strikes, main="Observed vs. Predicted")
abline(a = 0, b = 1, col = "red", lty = 2, lwd = 2)

#store predictions for figures 
y_pred_B7 <- predictions_df$sampled_pred
```

```{r}
rmse_B7 <- RMSE(y_pred_B7, test$strikes)
sscore_B7 <- calculate_sscore(obs=test$strikes, pred=y_pred_B7, nbins = 15, plot = FALSE)
cor_B7 <- cor(test$strikes, y_pred_B7)

param_table <- rbind(param_table, data.frame(scale = c("seasonal"),
                          distribution = c("gamma"),
                          model_name = c("B7"),
                          climate_var = c("P"),
                          alpha = c("a_alpha + b_alpha * P"),
                          a_alpha = a_alpha,
                          b_alpha = b_alpha,
                          c_alpha = NA,
                          d_alpha = NA,
                          e_alpha = NA,
                          f_alpha = NA,
                          g_alpha = NA,
                          beta = c("a_beta + b_beta * P"),
                          a_beta = a_beta,
                          b_beta = b_beta,
                          c_beta = NA,
                          d_beta = NA,
                          e_beta = NA,
                          f_beta = NA,
                          g_beta = NA))

```

# B8: Wind

S ~ gamma(alpha, beta);
alpha = a_alpha + b_alpha * W;
beta = a_beta + b_beta * W;

```{r, echo=FALSE, results='hide', include=FALSE}

#library(rstan)

dat <- list(
  N = nrow(train),
  S = train$strikes,
  W = train$wind
)


# Compile and fit the Stan model
if (!file.exists(file.path(rds_file_path, "compiled_gamma_B8.rds"))) {
  B8 <- stan(file = "gamma_wind.stan", data = dat, 
           iter = 2000, 
           chains = 4, 
           cores = min(parallel::detectCores(), 4))
    saveRDS(B8, file = file.path(rds_file_path, "compiled_gamma_B8.rds"))
    } else {
      B8 <- readRDS(file.path(rds_file_path, "compiled_gamma_B8.rds"))
    }
```


```{r}

print(B8, pars = c("a_alpha", "b_alpha", "a_beta", "b_beta"))

traceplot(B8)

parameter_stats <- summary(B8)$summary[, c("mean", "sd")][1:4, 1:2]
print(parameter_stats)

summary_table <- data.frame(
  parameter = rownames(parameter_stats),
  mean = parameter_stats[, "mean"],
  sd = parameter_stats[, "sd"]
)

ggplot(summary_table, aes(x = parameter, y = mean)) +
  geom_point(color = "blue", size = 3) +  # Point for the mean
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2) +  # Error bars for SD
  labs(y = "Parameter Estimate", x = "Parameter") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Parameter Means and SDs from Stan Model")

#store mean posterior sample for table 
a_alpha <- summary_table["a_alpha", "mean"]
b_alpha <- summary_table["b_alpha", "mean"]
a_beta <- summary_table["a_beta", "mean"]
b_beta  <- summary_table["b_beta ", "mean"]
```

Make predictions
```{r}
#Extract posterior samples
posterior_samples <- as.data.frame(B8)

#Extract individual parameters
a_alpha_samples <- posterior_samples$a_alpha
b_alpha_samples <- posterior_samples$b_alpha
a_beta_samples <- posterior_samples$a_beta
b_beta_samples <- posterior_samples$b_beta

#Number of posterior samples
num_samples <- length(a_alpha_samples)

#Number of test observations
num_test <- length(test$wind)

#Create vectors to store sampled alpha, beta, and predictions
sampled_alpha <- numeric(num_test)
sampled_beta <- numeric(num_test)
sampled_predictions <- numeric(num_test)

#Randomly select a posterior sample for each test observation
posterior_index <- sample(1:num_samples, num_test, replace = TRUE)

for (j in 1:num_test) {
  #Pick a random posterior sample index
  i <- posterior_index[j]  

  #Compute alpha and beta for the test observation
  sampled_alpha[j] <- a_alpha_samples[i] + b_alpha_samples[i] * test$wind[j]
  sampled_beta[j] <- a_beta_samples[i] + b_beta_samples[i] * test$wind[j]
  
  #Generate a single prediction from the Gamma distribution
  sampled_predictions[j] <- rgamma(1, shape = sampled_alpha[j], rate = sampled_beta[j])
}

#Create a dataframe with observed and predicted values
predictions_df <- data.frame(
  actual = test$strikes,      #Observed lightning strikes
  wind = test$wind,            #Climate predictor 
  alpha = sampled_alpha,      #Sampled alpha for each observation
  beta = sampled_beta,        #Sampled beta for each observation
  sampled_pred = sampled_predictions  # Sampled prediction
)

#View predictions
print(head(predictions_df))

hist(predictions_df$sampled_pred, breaks=30, main = "predictions")

hist(test$strikes, breaks=30, main = "observations")

plot(test$wind, predictions_df$alpha, main="Alpha")
plot(test$wind, predictions_df$beta, main="Beta")
plot(test$wind, predictions_df$sampled_pred, main="Lightning Predictions")
plot(test$wind, test$strikes, main="Lightning Observations")
plot(predictions_df$sampled_pred, test$strikes, main="Observed vs. Predicted")
abline(a = 0, b = 1, col = "red", lty = 2, lwd = 2)

#store predictions for figures 
y_pred_B8 <- predictions_df$sampled_pred
```

```{r}
rmse_B8 <- RMSE(y_pred_B8, test$strikes)
sscore_B8 <- calculate_sscore(obs=test$strikes, pred=y_pred_B8, nbins = 15, plot = FALSE)
cor_B8 <- cor(test$strikes, y_pred_B8)

param_table <- rbind(param_table, data.frame(scale = c("seasonal"),
                          distribution = c("gamma"),
                          model_name = c("B8"),
                          climate_var = c("W"),
                          alpha = c("a_alpha + b_alpha * W"),
                          a_alpha = a_alpha,
                          b_alpha = b_alpha,
                          c_alpha = NA,
                          d_alpha = NA,
                          e_alpha = NA,
                          f_alpha = NA,
                          g_alpha = NA,
                          beta = c("a_beta + b_beta * W"),
                          a_beta = a_beta,
                          b_beta = b_beta,
                          c_beta = NA,
                          d_beta = NA,
                          e_beta = NA,
                          f_beta = NA,
                          g_beta = NA))

```


# B9: Short Wave Radiation + Temperature

Lightning strike rate modeled from a gamma distribution where mu and sigma are dependent on climate: shortwave radiation and temperature, where SWR and temp have additive affects. They contribute independently to the mean lightning strike rate and standard deviation. swr and temp do not interact; ie. the effect of SWR on lighting is the same regardless of the temperature outside. 

    S ~ dgamma( mu , sigma )
    mu <- a_alpha + b_alpha * SWR + c_alpha * T
    sigma <- a_beta + b_beta * SWR + c_beta * T


```{r, echo=FALSE, results='hide', include=FALSE}

#library(rstan)

dat <- list(
  N = nrow(train),
  S = train$strikes,
  SWR = train$swr,
  T = train$tair
)


# Compile and fit the Stan model
if (!file.exists(file.path(rds_file_path, "compiled_gamma_B9.rds"))) {
  B9 <- stan(file = "gamma_swr_tair.stan", data = dat, 
           iter = 2000, 
           chains = 4, 
           cores = min(parallel::detectCores(), 4))
    saveRDS(B9, file = file.path(rds_file_path, "compiled_gamma_B9.rds"))
    } else {
      B9 <- readRDS(file.path(rds_file_path, "compiled_gamma_B9.rds"))
    }
```


```{r}

print(B9, pars = c("a_alpha", "b_alpha", "c_alpha", "a_beta", "b_beta", "c_beta"))

traceplot(B9)

parameter_stats <- summary(B9)$summary[, c("mean", "sd")][1:6, 1:2]
print(parameter_stats)

summary_table <- data.frame(
  parameter = rownames(parameter_stats),
  mean = parameter_stats[, "mean"],
  sd = parameter_stats[, "sd"]
)

ggplot(summary_table, aes(x = parameter, y = mean)) +
  geom_point(color = "blue", size = 3) +  # Point for the mean
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2) +  # Error bars for SD
  labs(y = "Parameter Estimate", x = "Parameter") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Parameter Means and SDs from Stan Model")

#store mean posterior sample for table 
a_alpha <- summary_table["a_alpha", "mean"]
b_alpha <- summary_table["b_alpha", "mean"]
c_alpha <- summary_table["c_alpha", "mean"]
a_beta  <- summary_table["a_beta", "mean"]
b_beta <- summary_table["b_beta", "mean"]
c_beta  <- summary_table["c_beta", "mean"]
```

Make predictions
```{r}
#Extract posterior samples
posterior_samples <- as.data.frame(B9)

#Extract individual parameters
a_alpha_samples <- posterior_samples$a_alpha
b_alpha_samples <- posterior_samples$b_alpha
c_alpha_samples <- posterior_samples$c_alpha
a_beta_samples <- posterior_samples$a_beta
b_beta_samples <- posterior_samples$b_beta
c_beta_samples <- posterior_samples$c_beta

#Number of posterior samples
num_samples <- length(a_alpha_samples)

#Number of test observations
num_test <- length(test$swr)

#Create vectors to store sampled alpha, beta, and predictions
sampled_alpha <- numeric(num_test)
sampled_beta <- numeric(num_test)
sampled_predictions <- numeric(num_test)

#Randomly select a posterior sample for each test observation
posterior_index <- sample(1:num_samples, num_test, replace = TRUE)

for (j in 1:num_test) {
  #Pick a random posterior sample index
  i <- posterior_index[j]  

  #Compute alpha and beta for the test observation
  sampled_alpha[j] <- a_alpha_samples[i] + b_alpha_samples[i] * test$swr[j] + c_alpha_samples[i] * test$tair[j]
  sampled_beta[j] <- a_beta_samples[i] + b_beta_samples[i] * test$swr[j] + c_alpha_samples[i] * test$tair[j]
  
  #Generate a single prediction from the Gamma distribution
  sampled_predictions[j] <- rgamma(1, shape = sampled_alpha[j], rate = sampled_beta[j])
}

#Create a dataframe with observed and predicted values
predictions_df <- data.frame(
  actual = test$strikes,      #Observed lightning strikes
  swr = test$swr,            #Climate predictor
  tair = test$tair,            #Climate predictor
  alpha = sampled_alpha,      #Sampled alpha for each observation
  beta = sampled_beta,        #Sampled beta for each observation
  sampled_pred = sampled_predictions  # Sampled prediction
)

#View predictions
print(head(predictions_df))

hist(predictions_df$sampled_pred, breaks=30, main = "predictions")

hist(test$strikes, breaks=30, main = "observations")

plot(test$swr, predictions_df$sampled_pred, color=test$tair, main="Lightning Predictions")
plot(test$swr, test$strikes, color=test$tair, main="Lightning Observations")
plot(predictions_df$sampled_pred, test$strikes, main="Observed vs. Predicted")
abline(a = 0, b = 1, col = "red", lty = 2, lwd = 2)

#store predictions for figures 
y_pred_B9 <- predictions_df$sampled_pred
```

```{r}
rmse_B9 <- RMSE(y_pred_B9, test$strikes)
sscore_B9 <- calculate_sscore(obs=test$strikes, pred=y_pred_B9, nbins = 15, plot = FALSE)
cor_B9 <- cor(test$strikes, y_pred_B9)

param_table <- rbind(param_table, data.frame(scale = c("seasonal"),
                          distribution = c("gamma"),
                          model_name = c("B9"),
                          climate_var = c("SWR, T"),
                          alpha = c("a_alpha + b_alpha * SWR + c_alpha * T"),
                          a_alpha = a_alpha,
                          b_alpha = b_alpha,
                          c_alpha = c_alpha,
                          d_alpha = NA,
                          e_alpha = NA,
                          f_alpha = NA,
                          g_alpha = NA,
                          beta = c("a_beta + b_beta * SWR + c_beta * T"),
                          a_beta = a_beta,
                          b_beta = b_beta,
                          c_beta = c_beta,
                          d_beta = NA,
                          e_beta = NA,
                          f_beta = NA,
                          g_beta = NA))

```

# B10: Short Wave Radiation + Temperature + Precipitation

Lightning strike rate modeled from a dgamma distribution where mu and sigma are dependent on climate: shortwave radiation and temperature, where SWR and temp have additive affects. They contribute independently to the mean lightning strike rate and standard deviation. swr and temp do not interact; ie. the effect of SWR on lighting is the same regardless of the temperature outside. 

    S ~ dgamma( mu , sigma ),
    mu <- a_alpha + b_alpha * SWR + c_alpha * T + d_alpha * RH,
    sigma <- a_beta + b_beta * SWR + c_beta * T+ d_beta * RH,
    
```{r, echo=FALSE, results='hide', include=FALSE}

#library(rstan)

dat <- list(
  N = nrow(train),
  S = train$strikes,
  SWR = train$swr,
  T = train$tair,
  RH = train$rh
)


# Compile and fit the Stan model
if (!file.exists(file.path(rds_file_path, "compiled_gamma_B10.rds"))) {
  B10 <- stan(file = "gamma_swr_tair_rh.stan", data = dat, 
           iter = 2000, 
           chains = 4, 
           cores = min(parallel::detectCores(), 4))
    saveRDS(B10, file = file.path(rds_file_path, "compiled_gamma_B10.rds"))
    } else {
      B10 <- readRDS(file.path(rds_file_path, "compiled_gamma_B10.rds"))
    }
```


```{r}

print(B10, pars = c("a_alpha", "b_alpha", "c_alpha", "d_alpha", "a_beta", "b_beta", "c_beta", "d_beta"))

traceplot(B10)

parameter_stats <- summary(B10)$summary[, c("mean", "sd")][1:8, 1:2]
print(parameter_stats)

summary_table <- data.frame(
  parameter = rownames(parameter_stats),
  mean = parameter_stats[, "mean"],
  sd = parameter_stats[, "sd"]
)

ggplot(summary_table, aes(x = parameter, y = mean)) +
  geom_point(color = "blue", size = 3) +  # Point for the mean
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2) +  # Error bars for SD
  labs(y = "Parameter Estimate", x = "Parameter") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Parameter Means and SDs from Stan Model")

#store mean posterior sample for table 
a_alpha <- summary_table["a_alpha", "mean"]
b_alpha <- summary_table["b_alpha", "mean"]
c_alpha <- summary_table["c_alpha", "mean"]
d_alpha <- summary_table["d_alpha", "mean"]
a_beta  <- summary_table["a_beta", "mean"]
b_beta <- summary_table["b_beta", "mean"]
c_beta  <- summary_table["c_beta", "mean"]
d_beta  <- summary_table["d_beta", "mean"]
```

Make predictions
```{r}
#Extract posterior samples
posterior_samples <- as.data.frame(B10)

#Extract individual parameters
a_alpha_samples <- posterior_samples$a_alpha
b_alpha_samples <- posterior_samples$b_alpha
c_alpha_samples <- posterior_samples$c_alpha
d_alpha_samples <- posterior_samples$d_alpha
a_beta_samples <- posterior_samples$a_beta
b_beta_samples <- posterior_samples$b_beta
c_beta_samples <- posterior_samples$c_beta
d_beta_samples <- posterior_samples$d_beta

#Number of posterior samples
num_samples <- length(a_alpha_samples)

#Number of test observations
num_test <- length(test$swr)

#Create vectors to store sampled alpha, beta, and predictions
sampled_alpha <- numeric(num_test)
sampled_beta <- numeric(num_test)
sampled_predictions <- numeric(num_test)

#Randomly select a posterior sample for each test observation
posterior_index <- sample(1:num_samples, num_test, replace = TRUE)

for (j in 1:num_test) {
  #Pick a random posterior sample index
  i <- posterior_index[j]  

  #Compute alpha and beta for the test observation
  sampled_alpha[j] <- a_alpha_samples[i] + b_alpha_samples[i] * test$swr[j] + c_alpha_samples[i] * test$tair[j] + d_alpha_samples[i] * test$rh[j]
  sampled_beta[j] <- a_beta_samples[i] + b_beta_samples[i] * test$swr[j] + c_alpha_samples[i] * test$tair[j] + d_alpha_samples[i] * test$rh[j]
  
  #Generate a single prediction from the Gamma distribution
  sampled_predictions[j] <- rgamma(1, shape = sampled_alpha[j], rate = sampled_beta[j])
}

#Create a dataframe with observed and predicted values
predictions_df <- data.frame(
  actual = test$strikes,      #Observed lightning strikes
  swr = test$swr,            #Climate predictor
  tair = test$tair,            #Climate predictor
  rh = test$rh,            #Climate predictor
  alpha = sampled_alpha,      #Sampled alpha for each observation
  beta = sampled_beta,        #Sampled beta for each observation
  sampled_pred = sampled_predictions  # Sampled prediction
)

#View predictions
print(head(predictions_df))

hist(predictions_df$sampled_pred, breaks=30, main = "predictions")

hist(test$strikes, breaks=30, main = "observations")

plot(test$swr, predictions_df$sampled_pred, color=test$rh, main="Lightning Predictions")
plot(test$swr, test$strikes, color=test$rh, main="Lightning Observations")
plot(predictions_df$sampled_pred, test$strikes, main="Observed vs. Predicted")
abline(a = 0, b = 1, col = "red", lty = 2, lwd = 2)

#store predictions for figures 
y_pred_B10 <- predictions_df$sampled_pred
```

```{r}
rmse_B10 <- RMSE(y_pred_B10, test$strikes)
sscore_B10 <- calculate_sscore(obs=test$strikes, pred=y_pred_B10, nbins = 15, plot = FALSE)
cor_B10 <- cor(test$strikes, y_pred_B10)

param_table <- rbind(param_table, data.frame(scale = c("seasonal"),
                          distribution = c("gamma"),
                          model_name = c("B10"),
                          climate_var = c("SWR, T, RH"),
                          alpha = c("a_alpha + b_alpha * SWR + c_alpha * T + d_alpha * RH"),
                          a_alpha = a_alpha,
                          b_alpha = b_alpha,
                          c_alpha = c_alpha,
                          d_alpha = d_alpha,
                          e_alpha = NA,
                          f_alpha = NA,
                          g_alpha = NA,
                          beta = c("a_beta + b_beta * SWR + c_beta * T + d_beta * RH"),
                          a_beta = a_beta,
                          b_beta = b_beta,
                          c_beta = c_beta,
                          d_beta = d_beta,
                          e_beta = NA,
                          f_beta = NA,
                          g_beta = NA))


```


# B11: Short Wave Radiation + Temperature + Precipitation + Wind

Lightning strike rate modeled from a dgamma distribution where mu and sigma are dependent on climate: shortwave radiation,  temperature, relative humidity, and wind. 
    S ~ dgamma( mu , sigma ),
    mu <- a_alpha + b_alpha * SWR + c_alpha * T + d_alpha * RH + e_alpha * W,
    sigma <- a_beta + b_beta * SWR + c_beta * T + d_beta * RH + e_beta * W,,
    
```{r, echo=FALSE, results='hide', include=FALSE}

#library(rstan)

dat <- list(
  N = nrow(train),
  S = train$strikes,
  SWR = train$swr,
  T = train$tair,
  RH = train$rh,
  W = train$wind
)

init_list <- function() {
  list(a_alpha = 1, b_alpha = 0.1, c_alpha = 0.1, d_alpha = 0.1, e_alpha = 0.1,
       a_beta = 1, b_beta = 0.1, c_beta = 0.1, d_beta = 0.1, e_beta = 0.1)
}

# Compile and fit the Stan model
if (!file.exists(file.path(rds_file_path, "compiled_gamma_B11.rds"))) {
  B11 <- stan(file = "gamma_swr_tair_rh_wind.stan", data = dat, 
           iter = 2000, 
           chains = 1, 
           init = init_list,
           cores = min(parallel::detectCores(), 4))
    saveRDS(B11, file = file.path(rds_file_path, "compiled_gamma_B11.rds"))
    } else {
      B11 <- readRDS(file.path(rds_file_path, "compiled_gamma_B11.rds"))
    }
```


```{r}

print(B11, pars = c("a_alpha", "b_alpha", "c_alpha", "d_alpha", "e_alpha", "a_beta", "b_beta", "c_beta", "d_beta", "e_beta"))

traceplot(B11)

parameter_stats <- summary(B11)$summary[, c("mean", "sd")][1:10, 1:2]
print(parameter_stats)

summary_table <- data.frame(
  parameter = rownames(parameter_stats),
  mean = parameter_stats[, "mean"],
  sd = parameter_stats[, "sd"]
)

ggplot(summary_table, aes(x = parameter, y = mean)) +
  geom_point(color = "blue", size = 3) +  # Point for the mean
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2) +  # Error bars for SD
  labs(y = "Parameter Estimate", x = "Parameter") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Parameter Means and SDs from Stan Model")

#store mean posterior sample for table
a_alpha <- summary_table["a_alpha", "mean"]
b_alpha <- summary_table["b_alpha", "mean"]
c_alpha <- summary_table["c_alpha", "mean"]
d_alpha <- summary_table["d_alpha", "mean"]
e_alpha <- summary_table["e_alpha", "mean"]
a_beta <- summary_table["a_beta", "mean"]
b_beta <- summary_table["b_beta", "mean"]
c_beta <- summary_table["c_beta", "mean"]
d_beta <- summary_table["d_beta", "mean"]
e_beta <- summary_table["e_beta", "mean"]
```

Make predictions
```{r}
#Extract posterior samples
posterior_samples <- as.data.frame(B11)

#Extract individual parameters
a_alpha_samples <- posterior_samples$a_alpha
b_alpha_samples <- posterior_samples$b_alpha
c_alpha_samples <- posterior_samples$c_alpha
d_alpha_samples <- posterior_samples$d_alpha
e_alpha_samples <- posterior_samples$e_alpha
a_beta_samples <- posterior_samples$a_beta
b_beta_samples <- posterior_samples$b_beta
c_beta_samples <- posterior_samples$c_beta
d_beta_samples <- posterior_samples$d_beta
e_beta_samples <- posterior_samples$e_beta

#Number of posterior samples
num_samples <- length(a_alpha_samples)

#Number of test observations
num_test <- length(test$swr)

#Create vectors to store sampled alpha, beta, and predictions
sampled_alpha <- numeric(num_test)
sampled_beta <- numeric(num_test)
sampled_predictions <- numeric(num_test)

#Randomly select a posterior sample for each test observation
posterior_index <- sample(1:num_samples, num_test, replace = TRUE)

for (j in 1:num_test) {
  #Pick a random posterior sample index
  i <- posterior_index[j]  

  #Compute alpha and beta for the test observation
  sampled_alpha[j] <- a_alpha_samples[i] + b_alpha_samples[i] * test$swr[j] + c_alpha_samples[i] * test$tair[j] + d_alpha_samples[i] * test$rh[j] + e_alpha_samples[i] * test$wind[j]
  sampled_beta[j] <- a_beta_samples[i] + b_beta_samples[i] * test$swr[j] + c_alpha_samples[i] * test$tair[j] + d_alpha_samples[i] * test$rh[j] + e_alpha_samples[i] * test$wind[j]
  
  #Generate a single prediction from the Gamma distribution
  sampled_predictions[j] <- rgamma(1, shape = sampled_alpha[j], rate = sampled_beta[j])
}

#Create a dataframe with observed and predicted values
predictions_df <- data.frame(
  actual = test$strikes,      #Observed lightning strikes
  swr = test$swr,            #Climate predictor
  tair = test$tair,            #Climate predictor
  rh = test$rh,            #Climate predictor
  wind = test$wind,            #Climate predictor
  alpha = sampled_alpha,      #Sampled alpha for each observation
  beta = sampled_beta,        #Sampled beta for each observation
  sampled_pred = sampled_predictions  # Sampled prediction
)

#View predictions
print(head(predictions_df))

hist(predictions_df$sampled_pred, breaks=30, main = "predictions")

hist(test$strikes, breaks=30, main = "observations")

plot(test$swr, predictions_df$sampled_pred, color=test$wind, main="Lightning Predictions")
plot(test$swr, test$strikes, color=test$wind, main="Lightning Observations")
plot(predictions_df$sampled_pred, test$strikes, main="Observed vs. Predicted")
abline(a = 0, b = 1, col = "red", lty = 2, lwd = 2)

#store predictions for figures 
y_pred_B11 <- predictions_df$sampled_pred
```

```{r}
rmse_B11 <- RMSE(y_pred_B11, test$strikes)
sscore_B11 <- calculate_sscore(obs=test$strikes, pred=y_pred_B11, nbins = 15, plot = FALSE)
cor_B11 <- cor(test$strikes, y_pred_B11)

param_table <- rbind(param_table, data.frame(scale = c("seasonal"),
                          distribution = c("gamma"),
                          model_name = c("B11"),
                          climate_var = c("SWR, T, RH, W"),
                          alpha = c("a_alpha + b_alpha * SWR + c_alpha * T + d_alpha * RH + e_alpha * W"),
                          a_alpha = a_alpha,
                          b_alpha = b_alpha,
                          c_alpha = c_alpha,
                          d_alpha = d_alpha,
                          e_alpha = e_alpha,
                          f_alpha = NA,
                          g_alpha = NA,
                          beta = c("a_beta + b_beta * SWR + c_beta * T + d_beta * RH + e_beta * W"),
                          a_beta = a_beta,
                          b_beta = b_beta,
                          c_beta = c_beta,
                          d_beta = d_beta,
                          e_beta = e_beta,
                          f_beta = NA,
                          g_beta = NA))

```

# B12: Short Wave Radiation + Temperature + Precipitation + Wind + Precipitation

Lightning strike rate modeled from a dgamma distribution where mu and sigma are dependent on climate: shortwave radiation,  temperature, relative humidity, wind, and precipitation. 
    S ~ dgamma( mu , sigma ),
    mu <- a_alpha + b_alpha * SWR + c_alpha * T + d_alpha * RH + e_alpha * W + f_alpha * P,
    sigma <- a_beta + b_beta * SWR + c_beta * T + d_beta * RH + e_beta * W + f_beta * P,
    
```{r, echo=FALSE, results='hide', include=FALSE}

#library(rstan)

dat <- list(
  N = nrow(train),
  S = train$strikes,
  SWR = train$swr,
  T = train$tair,
  RH = train$rh,
  W = train$wind,
  P = train$precip
)


# Compile and fit the Stan model
init_list <- function() {
  list(a_alpha = 0.1, b_alpha = 0.1, c_alpha = 0.1, d_alpha = 0.1, e_alpha = 0.1, f_alpha = 0.1,
       a_beta = 0.1, b_beta = 0.1, c_beta = 0.1, d_beta = 0.1, e_beta = 0.1, f_beta = 0.1)
}

if (!file.exists(file.path(rds_file_path, "compiled_gamma_B12.rds"))) {
  B12 <- stan(file = "gamma_swr_tair_rh_wind_precip.stan", 
            data = dat,
            iter = 2000, 
            chains = 4, 
            init = init_list,
            cores = min(parallel::detectCores(), 4))
    saveRDS(B12, file = file.path(rds_file_path, "compiled_gamma_B12.rds"))
    } else {
      B12 <- readRDS(file.path(rds_file_path, "compiled_gamma_B12.rds"))
    }

```


```{r}

print(B12, pars = c("a_alpha", "b_alpha", "c_alpha", "d_alpha", "e_alpha", "f_alpha", "a_beta", "b_beta", "c_beta", "d_beta", "e_beta", "f_beta"))

traceplot(B12)

parameter_stats <- summary(B12)$summary[, c("mean", "sd")][1:12, 1:2]
print(parameter_stats)

summary_table <- data.frame(
  parameter = rownames(parameter_stats),
  mean = parameter_stats[, "mean"],
  sd = parameter_stats[, "sd"]
)

ggplot(summary_table, aes(x = parameter, y = mean)) +
  geom_point(color = "blue", size = 3) +  # Point for the mean
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2) +  # Error bars for SD
  labs(y = "Parameter Estimate", x = "Parameter") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Parameter Means and SDs from Stan Model")

#store mean posterior sample for table
a_alpha <- summary_table["a_alpha", "mean"]
b_alpha <- summary_table["b_alpha", "mean"]
c_alpha <- summary_table["c_alpha", "mean"]
d_alpha <- summary_table["d_alpha", "mean"]
e_alpha <- summary_table["e_alpha", "mean"]
f_alpha <- summary_table["f_alpha", "mean"]
a_beta <- summary_table["a_beta", "mean"]
b_beta <- summary_table["b_beta", "mean"]
c_beta <- summary_table["c_beta", "mean"]
d_beta <- summary_table["d_beta", "mean"]
e_beta <- summary_table["e_beta", "mean"]
f_beta <- summary_table["f_beta", "mean"]
```

Make predictions
```{r}
#Extract posterior samples
posterior_samples <- as.data.frame(B12)

#Extract individual parameters
a_alpha_samples <- posterior_samples$a_alpha
b_alpha_samples <- posterior_samples$b_alpha
c_alpha_samples <- posterior_samples$c_alpha
d_alpha_samples <- posterior_samples$d_alpha
e_alpha_samples <- posterior_samples$e_alpha
f_alpha_samples <- posterior_samples$f_alpha
a_beta_samples <- posterior_samples$a_beta
b_beta_samples <- posterior_samples$b_beta
c_beta_samples <- posterior_samples$c_beta
d_beta_samples <- posterior_samples$d_beta
e_beta_samples <- posterior_samples$e_beta
f_beta_samples <- posterior_samples$f_beta

#Number of posterior samples
num_samples <- length(a_alpha_samples)

#Number of test observations
num_test <- length(test$swr)

#Create vectors to store sampled alpha, beta, and predictions
sampled_alpha <- numeric(num_test)
sampled_beta <- numeric(num_test)
sampled_predictions <- numeric(num_test)

#Randomly select a posterior sample for each test observation
posterior_index <- sample(1:num_samples, num_test, replace = TRUE)

for (j in 1:num_test) {
  # Pick a random posterior sample index
  i <- posterior_index[j]  
  
  # Compute alpha and beta using exp to enforce positivity
  sampled_alpha[j] <- exp(
    a_alpha_samples[i] + 
    b_alpha_samples[i] * test$swr[j] + 
    c_alpha_samples[i] * test$tair[j] + 
    d_alpha_samples[i] * test$rh[j] + 
    e_alpha_samples[i] * test$wind[j] + 
    f_alpha_samples[i] * test$precip[j]
  )
  
  sampled_beta[j] <- exp(
    a_beta_samples[i] + 
    b_beta_samples[i] * test$swr[j] + 
    c_beta_samples[i] * test$tair[j] + 
    d_beta_samples[i] * test$rh[j] + 
    e_beta_samples[i] * test$wind[j] + 
    f_beta_samples[i] * test$precip[j]
  )
  
  # Generate a single prediction from the Gamma distribution
  sampled_predictions[j] <- rgamma(1, shape = sampled_alpha[j], rate = sampled_beta[j])
}


#Create a dataframe with observed and predicted values
predictions_df <- data.frame(
  actual = test$strikes,      #Observed lightning strikes
  swr = test$swr,            #Climate predictor
  tair = test$tair,            #Climate predictor
  rh = test$rh,            #Climate predictor
  wind = test$wind,            #Climate predictor
  precip = test$precip,            #Climate predictor
  alpha = sampled_alpha,      #Sampled alpha for each observation
  beta = sampled_beta,        #Sampled beta for each observation
  sampled_pred = sampled_predictions  # Sampled prediction
)

#View predictions
print(head(predictions_df))

hist(predictions_df$sampled_pred, breaks=30, main = "predictions")

hist(test$strikes, breaks=30, main = "observations")

plot(predictions_df$swr, predictions_df$sampled_pred, main="Lightning Predictions")
plot(test$swr, test$strikes, main="Lightning Observations")
plot(predictions_df$sampled_pred, test$strikes, main="Observed vs. Predicted")
abline(a = 0, b = 1, col = "red", lty = 2, lwd = 2)

#store predictions for figures 
y_pred_B12 <- predictions_df$sampled_pred
```


```{r}
rmse_B12 <- RMSE(y_pred_B12, test$strikes)
sscore_B12 <- calculate_sscore(obs=test$strikes, pred=y_pred_B12, nbins = 15, plot = FALSE)
cor_B12 <- cor(test$strikes, y_pred_B12)

param_table <- rbind(param_table, data.frame(scale = c("seasonal"),
                          distribution = c("gamma"),
                          model_name = c("B12"),
                          climate_var = c("SWR, T, RH, W, P"),
                          alpha = c("a_alpha + b_alpha * SWR + c_alpha * T + d_alpha * RH + e_alpha * W + f_alpha * P"),
                          a_alpha = a_alpha,
                          b_alpha = b_alpha,
                          c_alpha = c_alpha,
                          d_alpha = d_alpha,
                          e_alpha = e_alpha,
                          f_alpha = f_alpha,
                          g_alpha = NA,
                          beta = c("a_beta + b_beta * SWR + c_beta * T + d_beta * RH + e_beta * W + f_beta * P"),
                          a_beta = a_beta,
                          b_beta = b_beta,
                          c_beta = c_beta,
                          d_beta = d_beta,
                          e_beta = e_beta,
                          f_beta = f_beta,
                          g_beta = NA))
```

# B13: Short Wave Radiation + Temperature + Precipitation + Wind + Precipitation + Surface Pressure

Lightning strike rate modeled from a gamma distribution where mu and sigma are dependent on climate: shortwave radiation,  temperature, relative humidity, wind, precipitation, and surface pressure
. 
    S ~ dgamma( mu , sigma ),
    mu <- a_alpha + b_alpha * SWR + c_alpha * T + d_alpha * RH + e_alpha * W + f_alpha * P + g_alpha * SP,
    sigma <- a_beta + b_beta * SWR + c_beta * T + d_beta * RH + e_beta * W + f_beta * P + g_beta * SP,
    
```{r, echo=FALSE, results='hide', include=FALSE}

#library(rstan)

dat <- list(
  N = nrow(train),
  S = train$strikes,
  SWR = train$swr,
  T = train$tair,
  RH = train$rh,
  W = train$wind,
  P = train$precip,
  SP = train$sp
)


# Compile and fit the Stan model
init_list <- function() {
  list(a_alpha = 1, b_alpha = 0.1, c_alpha = 0.1, d_alpha = 0.1, e_alpha = 0.1, f_alpha = 0.1, g_alpha = 0.1,
       a_beta = 1, b_beta = 0.1, c_beta = 0.1, d_beta = 0.1, e_beta = 0.1, f_beta = 0.1, g_beta = 0.1)
}

if (!file.exists(file.path(rds_file_path, "compiled_gamma_B13.rds"))) {
  B13 <- stan(file = "gamma_swr_tair_rh_wind_precip_sp.stan", 
            data = dat,
            iter = 2000, 
            chains = 4, 
            init = init_list,
            cores = min(parallel::detectCores(), 4))
    saveRDS(B13, file = file.path(rds_file_path, "compiled_gamma_B13.rds"))
    } else {
      B13 <- readRDS(file.path(rds_file_path, "compiled_gamma_B13.rds"))
    }

```


```{r}

print(B13, pars = c("a_alpha", "b_alpha", "c_alpha", "d_alpha", "e_alpha", "f_alpha", "g_alpha", "a_beta", "b_beta", "c_beta", "d_beta", "e_beta", "f_beta", "g_beta"))

traceplot(B13)

parameter_stats <- summary(B13)$summary[, c("mean", "sd")][1:14, 1:2]
print(parameter_stats)

summary_table <- data.frame(
  parameter = rownames(parameter_stats),
  mean = parameter_stats[, "mean"],
  sd = parameter_stats[, "sd"]
)

ggplot(summary_table, aes(x = parameter, y = mean)) +
  geom_point(color = "blue", size = 3) +  # Point for the mean
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2) +  # Error bars for SD
  labs(y = "Parameter Estimate", x = "Parameter") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Parameter Means and SDs from Stan Model")

#store mean posterior sample for table
a_alpha <- summary_table["a_alpha", "mean"]
b_alpha <- summary_table["b_alpha", "mean"]
c_alpha <- summary_table["c_alpha", "mean"]
d_alpha <- summary_table["d_alpha", "mean"]
e_alpha <- summary_table["e_alpha", "mean"]
f_alpha <- summary_table["f_alpha", "mean"]
g_alpha <- summary_table["g_alpha", "mean"]
a_beta <- summary_table["a_beta", "mean"]
b_beta <- summary_table["b_beta", "mean"]
c_beta <- summary_table["c_beta", "mean"]
d_beta <- summary_table["d_beta", "mean"]
e_beta <- summary_table["e_beta", "mean"]
f_beta <- summary_table["f_beta", "mean"]
g_beta <- summary_table["g_beta", "mean"]
```

Make predictions
```{r}
#Extract posterior samples
posterior_samples <- as.data.frame(B13)

#Extract individual parameters
a_alpha_samples <- posterior_samples$a_alpha
b_alpha_samples <- posterior_samples$b_alpha
c_alpha_samples <- posterior_samples$c_alpha
d_alpha_samples <- posterior_samples$d_alpha
e_alpha_samples <- posterior_samples$e_alpha
f_alpha_samples <- posterior_samples$f_alpha
g_alpha_samples <- posterior_samples$g_alpha
a_beta_samples <- posterior_samples$a_beta
b_beta_samples <- posterior_samples$b_beta
c_beta_samples <- posterior_samples$c_beta
d_beta_samples <- posterior_samples$d_beta
e_beta_samples <- posterior_samples$e_beta
f_beta_samples <- posterior_samples$f_beta
g_beta_samples <- posterior_samples$g_beta

#Number of posterior samples
num_samples <- length(a_alpha_samples)

#Number of test observations
num_test <- length(test$swr)

#Create vectors to store sampled alpha, beta, and predictions
sampled_alpha <- numeric(num_test)
sampled_beta <- numeric(num_test)
sampled_predictions <- numeric(num_test)

#Randomly select a posterior sample for each test observation
posterior_index <- sample(1:num_samples, num_test, replace = TRUE)

for (j in 1:num_test) {
  #Pick a random posterior sample index
  i <- posterior_index[j]  

  #Compute alpha and beta for the test observation
  sampled_alpha[j] <- exp(a_alpha_samples[i] + b_alpha_samples[i] * test$swr[j] + c_alpha_samples[i] * test$tair[j] + d_alpha_samples[i] * test$rh[j] + e_alpha_samples[i] * test$wind[j] + f_alpha_samples[i] * test$precip[j] + g_alpha_samples[i] * test$sp[j])
  sampled_beta[j] <- exp(a_beta_samples[i] + b_beta_samples[i] * test$swr[j] + c_alpha_samples[i] * test$tair[j] + d_alpha_samples[i] * test$rh[j] + e_alpha_samples[i] * test$wind[j] + f_alpha_samples[i] * test$precip[j] + g_alpha_samples[i] * test$sp[j])
  
  #Generate a single prediction from the Gamma distribution
  sampled_predictions[j] <- rgamma(1, shape = sampled_alpha[j], rate = sampled_beta[j])
}

#Create a dataframe with observed and predicted values
predictions_df <- data.frame(
  actual = test$strikes,      #Observed lightning strikes
  swr = test$swr,            #Climate predictor
  tair = test$tair,            #Climate predictor
  rh = test$rh,            #Climate predictor
  wind = test$wind,            #Climate predictor
  precip = test$precip,            #Climate predictor
  sp = test$sp,            #Climate predictor
  alpha = sampled_alpha,      #Sampled alpha for each observation
  beta = sampled_beta,        #Sampled beta for each observation
  sampled_pred = sampled_predictions  # Sampled prediction
)

#View predictions
print(head(predictions_df))

hist(predictions_df$sampled_pred, breaks=30, main = "predictions")

hist(test$strikes, breaks=30, main = "observations")

plot(test$swr, predictions_df$sampled_pred, color=test$sp, main="Lightning Predictions")
plot(test$swr, test$strikes, color=test$sp, main="Lightning Observations")
plot(predictions_df$sampled_pred, test$strikes, main="Observed vs. Predicted")
abline(a = 0, b = 1, col = "red", lty = 2, lwd = 2)

#store predictions for figures 
y_pred_B13 <- predictions_df$sampled_pred
```

```{r}
rmse_B13 <- RMSE(y_pred_B13, test$strikes)
sscore_B13 <- calculate_sscore(obs=test$strikes, pred=y_pred_B13, nbins = 15, plot = FALSE)
cor_B13 <- cor(test$strikes, y_pred_B13)

param_table <- rbind(param_table, data.frame(scale = c("seasonal"),
                          distribution = c("gamma"),
                          model_name = c("B13"),
                          climate_var = c("SWR, T, RH, W, P, SP"),
                          alpha = c("a_alpha + b_alpha * SWR + c_alpha * T + d_alpha * RH + e_alpha * W + f_alpha * P + g_alpha * SP"),
                          a_alpha = a_alpha,
                          b_alpha = b_alpha,
                          c_alpha = c_alpha,
                          d_alpha = d_alpha,
                          e_alpha = e_alpha,
                          f_alpha = f_alpha,
                          g_alpha = g_alpha,
                          beta = c("a_beta + b_beta * SWR + c_beta * T + d_beta * RH + e_beta * W + f_beta * P + g_beta * SP"),
                          a_beta = a_beta,
                          b_beta = b_beta,
                          c_beta = c_beta,
                          d_beta = d_beta,
                          e_beta = e_beta,
                          f_beta = f_beta,
                          g_beta = g_beta))

```

#Table of Predictions
```{r}
predictions <- data.frame(cbind(y_pred_B1, y_pred_B2, y_pred_B3, y_pred_B4, y_pred_B5, y_pred_B6, y_pred_B7, y_pred_B8, y_pred_B9, y_pred_B10, y_pred_B11, y_pred_B12, y_pred_B13))

print(predictions)

write.csv(predictions, file.path(table_file_path, "bayes_gamma_model_predictions.csv"))
```

#Table of Performance Metrics
```{r}
model_name <- c("B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "B10", "B11", "B12", "B13")
fitting_function <- rep("stan", 13)
distribution <- rep("gamma", 13)
group_name <- rep("Gamma Bayesian", 13)
predictors <- c("CAPE", "CAPE x P", "RH", "SWR", "T", "SP", "P", "W", "SWR + T", "SWR + T + RH", "SWR + T + RH + W", "SWR + T + RH + W + + P", "SWR + T + RH + W + P + SP")

#Root Mean Squared Error (RMSE)
RMSE = c(rmse_B1, rmse_B2, rmse_B3, rmse_B4, rmse_B5, rmse_B6, rmse_B7, rmse_B8, rmse_B9, rmse_B10, rmse_B11, rmse_B12, rmse_B13)
#Correlation between observed and predicted
cor <- c(cor_B1, cor_B2, cor_B3, cor_B4, cor_B5, cor_B6, cor_B7, cor_B8, cor_B9, cor_B10, cor_B11, cor_B12, cor_B13)
#S-Score
S_score <- c(sscore_B1, sscore_B2, sscore_B3, sscore_B4, sscore_B5, sscore_B6, sscore_B7, sscore_B8, sscore_B9, sscore_B10, sscore_B11, sscore_B12, sscore_B13)

model_comparison <- data.frame(cbind(model_name, fitting_function, distribution, predictors, group_name, RMSE, cor, S_score))

write.csv(model_comparison, file.path(table_file_path, "bayes_gamma_model_performance.csv"))

print(model_comparison)

```

#Add confidence intervals (mean estiamte +- 1.96 x SE for posterior estimates) to the param_table and export
```{r}
# Format mean Â± 1.96*sd
format_ci <- function(mean, sd) {
  if (is.na(mean) || is.na(sd)) return(NA)
  sprintf("%.3f Â± %.3f", mean, 1.96 * sd)
}

# All possible parameters
all_params <- c("a_alpha", "b_alpha", "c_alpha", "d_alpha", "e_alpha", "f_alpha", "g_alpha",
                "a_beta", "b_beta", "c_beta", "d_beta", "e_beta", "f_beta", "g_beta")

# Loop through models and safely extract only present parameters
formatted_param_list <- lapply(seq_along(models), function(i) {
  mod <- models[[i]]
  name <- model_names[i]
  
  # Summary of this model
  sum_stats <- summary(mod)$summary
  available_params <- intersect(rownames(sum_stats), all_params)
  
  # Initialize result with NAs
  formatted_values <- setNames(rep(NA, length(all_params)), all_params)
  
  # Format those that exist
  for (p in available_params) {
    formatted_values[p] <- format_ci(sum_stats[p, "mean"], sum_stats[p, "sd"])
  }
  
  # Return row as a data frame
  data.frame(model = name, as.list(formatted_values), check.names = FALSE)
})

# Combine to full table
formatted_param_table <- do.call(rbind, formatted_param_list)

# View result
print(formatted_param_table)


# Export table
write.csv(formatted_param_table, file = file.path(table_file_path, "Table_5.csv"), row.names = FALSE)
```

